æ™ºèƒ½åˆçº¦çš„ç”Ÿå‘½å‘¨æœŸæ¶µç›–äº†ä»æ„æ€åˆ°ç»ˆæ­¢çš„å®Œæ•´è¿‡ç¨‹ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†çš„é˜¶æ®µåˆ†æï¼š

## ğŸ“Š æ™ºèƒ½åˆçº¦ç”Ÿå‘½å‘¨æœŸé˜¶æ®µå›¾

```
æ„æ€è®¾è®¡ â†’ å¼€å‘æµ‹è¯• â†’ éƒ¨ç½²åˆå§‹åŒ– â†’ æ´»è·ƒè¿è¡Œ â†’ ç»´æŠ¤å‡çº§ â†’ ç»ˆæ­¢é”€æ¯
```

## 1. ğŸ’¡ æ„æ€å’Œè®¾è®¡é˜¶æ®µ

### éœ€æ±‚åˆ†æå’Œè§„åˆ’
```solidity
// è®¾è®¡é˜¶æ®µçš„ä¼ªä»£ç ç¤ºä¾‹
contract DesignPhase {
    // ç¡®å®šæ ¸å¿ƒåŠŸèƒ½ï¼š
    // âœ… ä»£å¸è½¬è´¦
    // âœ… ä½™é¢æŸ¥è¯¢  
    // âœ… æƒé™ç®¡ç†
    // âœ… äº‹ä»¶è®°å½•
    
    // å®‰å…¨è€ƒè™‘ï¼š
    // âŒ é‡å…¥æ”»å‡»é˜²æŠ¤
    // âŒ æ•´æ•°æº¢å‡ºæ£€æŸ¥
    // âŒ è®¿é—®æ§åˆ¶
}
```

### æŠ€æœ¯é€‰å‹å†³ç­–
- **åŒºå—é“¾å¹³å°**ï¼šä»¥å¤ªåŠã€Polygonã€BNB Chain
- **å¼€å‘æ¡†æ¶**ï¼šHardhatã€Foundryã€Truffle
- **ç¼–ç¨‹è¯­è¨€**ï¼šSolidityã€Vyperã€Rust
- **å­˜å‚¨æ–¹æ¡ˆ**ï¼šé“¾ä¸Šå­˜å‚¨ã€IPFSã€Arweave

## 2. ğŸ”¨ å¼€å‘å’Œæµ‹è¯•é˜¶æ®µ

### åˆçº¦ç¼–å†™
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenLifecycle {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    address public owner;
    
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    // ç”Ÿå‘½å‘¨æœŸçŠ¶æ€è·Ÿè¸ª
    enum ContractState { Deployed, Active, Paused, Upgraded, Destroyed }
    ContractState public currentState;
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    modifier onlyActive() {
        require(currentState == ContractState.Active, "Contract not active");
        _;
    }
}
```

### æµ‹è¯•å¥—ä»¶
```javascript
// æµ‹è¯•ç”Ÿå‘½å‘¨æœŸå„é˜¶æ®µ
const { expect } = require("chai");

describe("TokenLifecycle", function() {
    let token, owner, user1, user2;
    
    beforeEach(async function() {
        [owner, user1, user2] = await ethers.getSigners();
        const Token = await ethers.getContractFactory("TokenLifecycle");
        token = await Token.deploy("Test Token", "TEST", 18, 1000000);
    });
    
    it("åº”è¯¥æ­£ç¡®åˆå§‹åŒ–", async function() {
        expect(await token.name()).to.equal("Test Token");
        expect(await token.totalSupply()).to.equal(1000000);
        expect(await token.currentState()).to.equal(0); // Deployed
    });
    
    it("åº”è¯¥å…è®¸æ´»è·ƒçŠ¶æ€ä¸‹çš„è½¬è´¦", async function() {
        await token.activate(); // åˆ‡æ¢åˆ°æ´»è·ƒçŠ¶æ€
        await token.transfer(user1.address, 1000);
        expect(await token.balanceOf(user1.address)).to.equal(1000);
    });
    
    it("åº”è¯¥åœ¨æš‚åœçŠ¶æ€ä¸‹é˜»æ­¢è½¬è´¦", async function() {
        await token.pause();
        await expect(token.transfer(user1.address, 1000))
            .to.be.revertedWith("Contract not active");
    });
});
```

### å®‰å…¨å®¡è®¡
```javascript
// å®‰å…¨æµ‹è¯•ç¤ºä¾‹
describe("å®‰å…¨æµ‹è¯•", function() {
    it("åº”è¯¥é˜²æ­¢é‡å…¥æ”»å‡»", async function() {
        // éƒ¨ç½²æ¶æ„åˆçº¦å°è¯•é‡å…¥
        const MaliciousContract = await ethers.getContractFactory("MaliciousReceiver");
        const malicious = await MaliciousContract.deploy(token.address);
        
        await expect(malicious.attack({ value: ethers.utils.parseEther("1") }))
            .to.be.reverted;
    });
    
    it("åº”è¯¥æ­£ç¡®å¤„ç†æ•´æ•°æº¢å‡º", async function() {
        const maxUint = ethers.constants.MaxUint256;
        await expect(token.transfer(owner.address, maxUint))
            .to.be.reverted;
    });
});
```

## 3. ğŸš€ éƒ¨ç½²å’Œåˆå§‹åŒ–é˜¶æ®µ

### éƒ¨ç½²è„šæœ¬
```javascript
// éƒ¨ç½²è„šæœ¬ - å¤„ç†åˆå§‹åŒ–é€»è¾‘
async function main() {
    const [deployer] = await ethers.getSigners();
    
    console.log("éƒ¨ç½²åˆçº¦ï¼Œè´¦æˆ·:", deployer.address);
    console.log("è´¦æˆ·ä½™é¢:", (await deployer.getBalance()).toString());
    
    // éƒ¨ç½²åˆçº¦
    const Token = await ethers.getContractFactory("TokenLifecycle");
    const token = await Token.deploy(
        "My Token",
        "MTK",
        18,
        ethers.utils.parseEther("1000000")
    );
    
    await token.deployed();
    
    console.log("Token éƒ¨ç½²åœ°å€:", token.address);
    console.log("äº¤æ˜“å“ˆå¸Œ:", token.deployTransaction.hash);
    
    // åˆå§‹åŒ–åˆçº¦çŠ¶æ€
    await token.activate();
    console.log("åˆçº¦å·²æ¿€æ´»");
    
    // éªŒè¯éƒ¨ç½²
    await verifyContract(token.address, [
        "My Token",
        "MTK", 
        18,
        ethers.utils.parseEther("1000000")
    ]);
}

async function verifyContract(contractAddress, args) {
    console.log("ç­‰å¾…åŒºå—ç¡®è®¤...");
    await sleep(30000); // ç­‰å¾… 30 ç§’
    
    try {
        await run("verify:verify", {
            address: contractAddress,
            constructorArguments: args,
        });
        console.log("åˆçº¦éªŒè¯æˆåŠŸ");
    } catch (error) {
        console.log("åˆçº¦éªŒè¯å¤±è´¥:", error);
    }
}
```

### åˆå§‹åŒ–è¿‡ç¨‹
```solidity
// éƒ¨ç½²åçš„åˆå§‹åŒ–é€»è¾‘
function activate() public onlyOwner {
    require(currentState == ContractState.Deployed, "Already activated");
    currentState = ContractState.Active;
    emit ContractActivated(block.timestamp);
}

function initializeTreasury() public onlyOwner {
    require(currentState == ContractState.Active, "Contract not active");
    _balances[owner] = totalSupply;
    emit Transfer(address(0), owner, totalSupply);
}
```

## 4. âš¡ æ´»è·ƒè¿è¡Œé˜¶æ®µ

### æ­£å¸¸è¿è¥
```solidity
// æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
function transfer(address to, uint256 amount) public onlyActive returns (bool) {
    require(_balances[msg.sender] >= amount, "Insufficient balance");
    
    _balances[msg.sender] -= amount;
    _balances[to] += amount;
    
    emit Transfer(msg.sender, to, amount);
    return true;
}

function approve(address spender, uint256 amount) public onlyActive returns (bool) {
    _allowances[msg.sender][spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
}
```

### çŠ¶æ€ç›‘æ§
```javascript
// ç›‘æ§åˆçº¦å¥åº·çŠ¶å†µ
class ContractMonitor {
    constructor(contractAddress, abi) {
        this.contract = new ethers.Contract(contractAddress, abi, provider);
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // ç›‘æ§å…³é”®äº‹ä»¶
        this.contract.on("Transfer", (from, to, value, event) => {
            this.logTransaction(from, to, value);
            this.checkAnomalies(from, to, value);
        });
        
        this.contract.on("ContractPaused", (by, timestamp) => {
            this.alertAdmins("åˆçº¦è¢«æš‚åœ");
        });
    }
    
    checkAnomalies(from, to, value) {
        // æ£€æµ‹å¼‚å¸¸äº¤æ˜“æ¨¡å¼
        if (value > this.largeTransferThreshold) {
            this.alertAdmins(`å¤§é¢è½¬è´¦: ${value} from ${from} to ${to}`);
        }
    }
}
```

## 5. ğŸ› ï¸ ç»´æŠ¤å’Œå‡çº§é˜¶æ®µ

### å¯å‡çº§åˆçº¦æ¨¡å¼
```solidity
// ä»£ç†åˆçº¦ - å®ç°å¯å‡çº§æ€§
contract TokenProxy {
    address public implementation;
    address public admin;
    
    constructor(address _implementation) {
        admin = msg.sender;
        implementation = _implementation;
    }
    
    function upgrade(address newImplementation) external {
        require(msg.sender == admin, "Only admin");
        implementation = newImplementation;
    }
    
    fallback() external payable {
        address impl = implementation;
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}
```

### ç´§æ€¥æƒ…å†µå¤„ç†
```solidity
// ç´§æ€¥åœæ­¢æœºåˆ¶
function pause() public onlyOwner {
    require(currentState == ContractState.Active, "Already paused");
    currentState = ContractState.Paused;
    emit ContractPaused(msg.sender, block.timestamp);
}

function resume() public onlyOwner {
    require(currentState == ContractState.Paused, "Not paused");
    currentState = ContractState.Active;
    emit ContractResumed(msg.sender, block.timestamp);
}

function emergencyWithdraw(address token, uint256 amount) public onlyOwner {
    // ç´§æ€¥æƒ…å†µä¸‹æå–èµ„é‡‘
    IERC20(token).transfer(owner, amount);
}
```

## 6. ğŸ ç»ˆæ­¢å’Œé”€æ¯é˜¶æ®µ

### æœ‰è®¡åˆ’åœ°ç»ˆæ­¢
```solidity
// åˆçº¦ç»ˆæ­¢é€»è¾‘
function destroy() public onlyOwner {
    require(currentState != ContractState.Destroyed, "Already destroyed");
    
    // 1. ç¡®ä¿æ‰€æœ‰èµ„é‡‘å·²æå–
    uint256 contractBalance = address(this).balance;
    if (contractBalance > 0) {
        payable(owner).transfer(contractBalance);
    }
    
    // 2. è½¬ç§»å‰©ä½™ä»£å¸
    uint256 tokenBalance = _balances[address(this)];
    if (tokenBalance > 0) {
        _balances[owner] += tokenBalance;
        _balances[address(this)] = 0;
        emit Transfer(address(this), owner, tokenBalance);
    }
    
    // 3. æ›´æ–°çŠ¶æ€å¹¶è‡ªæ¯
    currentState = ContractState.Destroyed;
    emit ContractDestroyed(msg.sender, block.timestamp);
    
    // 4. è‡ªæ¯åˆçº¦ï¼ˆè°¨æ…ä½¿ç”¨ï¼‰
    selfdestruct(payable(owner));
}
```

### æ•°æ®è¿ç§»å’Œå½’æ¡£
```javascript
// ç»ˆæ­¢å‰çš„æ•°æ®å¤‡ä»½
class ContractEOLManager {
    async backupContractData(contractAddress) {
        const finalState = {
            timestamp: Date.now(),
            blockNumber: await provider.getBlockNumber(),
            totalSupply: await contract.totalSupply(),
            holderCount: await this.getHolderCount(),
            finalBalances: await this.snapshotBalances(),
            events: await this.exportEventHistory()
        };
        
        // ä¿å­˜åˆ° IPFS æˆ–ä¸­å¿ƒåŒ–å­˜å‚¨
        const ipfsHash = await this.saveToIPFS(finalState);
        console.log("åˆçº¦æœ€ç»ˆçŠ¶æ€å·²å¤‡ä»½:", ipfsHash);
        
        return ipfsHash;
    }
    
    async getHolderCount() {
        // è·å–æ‰€æœ‰æŒå¸åœ°å€æ•°é‡
        // å®é™…å®ç°å¯èƒ½éœ€è¦éå†äº‹ä»¶æˆ–ä½¿ç”¨ The Graph
    }
}
```

## ğŸ“ˆ ç”Ÿå‘½å‘¨æœŸç›‘æ§æŒ‡æ ‡

### å…³é”®æ€§èƒ½æŒ‡æ ‡
```solidity
// åˆçº¦å†…éƒ¨ç»Ÿè®¡
contract LifecycleMetrics {
    uint256 public totalTransactions;
    uint256 public uniqueUsers;
    uint256 public totalVolume;
    uint256 public contractCreationTime;
    
    mapping(address => bool) private _hasInteracted;
    
    function _updateMetrics(address user, uint256 value) internal {
        totalTransactions++;
        totalVolume += value;
        
        if (!_hasInteracted[user]) {
            uniqueUsers++;
            _hasInteracted[user] = true;
        }
    }
    
    function getUptime() public view returns (uint256) {
        return block.timestamp - contractCreationTime;
    }
    
    function getDailyActiveUsers() public view returns (uint256) {
        // éœ€è¦å¤–éƒ¨ç´¢å¼•å™¨æ”¯æŒ
        return 0;
    }
}
```

## âš ï¸ ç”Ÿå‘½å‘¨æœŸé£é™©å’Œç¼“è§£æªæ–½

### å¸¸è§é£é™©
1. **éƒ¨ç½²é£é™©**ï¼šæ„é€ å‡½æ•°é”™è¯¯ã€åˆå§‹åŒ–å¤±è´¥
2. **è¿è¥é£é™©**ï¼šgas è´¹ç”¨è¿‡é«˜ã€ç½‘ç»œæ‹¥å µ
3. **å®‰å…¨é£é™©**ï¼šæ¼æ´åˆ©ç”¨ã€ç§é’¥æ³„éœ²
4. **å‡çº§é£é™©**ï¼šè¿ç§»å¤±è´¥ã€æ•°æ®ä¸ä¸€è‡´
5. **ç»ˆæ­¢é£é™©**ï¼šèµ„é‡‘é”å®šã€ç”¨æˆ·æŸå¤±

### æœ€ä½³å®è·µ
- âœ… å……åˆ†æµ‹è¯•å’Œå®¡è®¡
- âœ… æ¸è¿›å¼éƒ¨ç½²ï¼ˆæµ‹è¯•ç½‘ â†’ ä¸»ç½‘ï¼‰
- âœ… å¤šç­¾åç®¡ç†é‡è¦æ“ä½œ
- âœ… å®Œå–„çš„ç›‘æ§å’Œå‘Šè­¦
- âœ… æ¸…æ™°çš„å‡çº§å’Œç»ˆæ­¢è®¡åˆ’

æ™ºèƒ½åˆçº¦çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸç®¡ç†æ˜¯ç¡®ä¿é¡¹ç›®æˆåŠŸå’Œå®‰å…¨è¿è¡Œçš„å…³é”®ã€‚æ¯ä¸ªé˜¶æ®µéƒ½éœ€è¦ä»”ç»†è§„åˆ’å’Œæ‰§è¡Œï¼Œç‰¹åˆ«æ˜¯åœ¨æ¶‰åŠç”¨æˆ·èµ„é‡‘çš„æƒ…å†µä¸‹ã€‚